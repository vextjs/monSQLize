# monSQLize 验证体系说明

> **版本**: v1.0.0  
> **创建日期**: 2026-02-03  
> **最后更新**: 2026-02-03

---


## 📋 目录

- [验证体系概述](#-验证体系概述)
- [目录结构说明](#-目录结构说明)
- [文件命名规范](#-文件命名规范)
- [验证流程](#-验证流程)
- [验证状态追踪](#-验证状态追踪)
- [快速开始](#-快速开始)
- [常见问题](#-常见问题)

---

## 📖 验证体系概述

monSQLize 验证体系旨在确保项目文档与实际代码实现的一致性，通过系统化的验证流程，保证文档的准确性和可靠性。

### 验证目标

- ✅ **文档准确性**: 验证文档描述与代码实现完全一致
- ✅ **功能完整性**: 确保所有功能都有对应的验证
- ✅ **自动化测试**: 通过脚本自动化验证过程
- ✅ **持续追踪**: 实时跟踪验证进度和状态

### 验证范围

- **85 个功能模块**: 覆盖 monSQLize 的所有核心功能
- **71 个已有文档**: 现有文档的验证
- **14 个规划文档**: 待创建文档的规划

---

## 📁 目录结构说明

```
validation/
├── README.md                          # 本文件 - 验证体系说明
├── VERIFICATION-PROGRESS.md           # 总进度追踪文档
│
├── checklists/                        # 验证清单目录
│   ├── connect.md                     # 连接管理验证清单
│   ├── find.md                        # find 查询验证清单
│   └── ...                            # 其他功能验证清单
│
├── validators/                        # 验证脚本目录
│   ├── connect.ts                     # 连接管理验证脚本
│   ├── find.ts                        # find 查询验证脚本
│   └── ...                            # 其他功能验证脚本
│
└── reports/                           # 验证报告目录
    ├── connect-validation-report.md   # 连接管理验证报告
    ├── CHECKLIST-UPDATE-SUMMARY.md    # 验证清单更新总结
    └── ...                            # 其他验证报告
```

### 各目录说明

#### 1. `checklists/` - 验证清单目录

**用途**: 存放各功能模块的详细验证清单

**文件格式**:
- 文件名: `{功能名}.md`
- 示例: `connect.md`, `find.md`, `aggregate.md`

**内容结构**:
- 验证状态概览
- 快速导航
- 详细验证清单（按分类组织）
- 验证统计
- 验证记录

#### 2. `validators/` - 验证脚本目录

**用途**: 存放自动化验证脚本

**文件格式**:
- 文件名: `{功能名}.ts` 或 `{功能名}.js`
- 示例: `connect.ts`, `find.ts`

**脚本要求**:
- 可独立运行
- 包含完整的断言和验证逻辑
- 输出详细的验证结果
- 通过率统计

#### 3. `reports/` - 验证报告目录

**用途**: 存放验证完成后生成的报告文档

**文件格式**:
- 验证报告: `{功能名}-validation-report.md`
- 总结文档: `{主题}-summary.md`

**报告内容**:
- 验证结果摘要
- 详细验证数据
- 文档准确性评估
- 问题发现和改进建议

---

## 📚 文档引用关系说明

### 引用关系建立原则

**文档之间的引用关系必须基于实际的逻辑关联，不能随意建立。**

#### 什么时候应该建立引用关系？

只有满足以下**任一**条件时，才应该在文档 A 中引用文档 B：

| 关系类型 | 说明 | 示例 |
|---------|------|------|
| **依赖关系** | 使用 A 功能前必须先理解 B 功能 | `multi-pool.md` → `connection.md`（多连接池依赖连接管理） |
| **扩展关系** | B 是 A 的详细展开或深入说明 | `multi-pool.md` → `multi-pool-health-check.md`（健康检查是多连接池的一部分） |
| **配套关系** | A 和 B 通常一起使用 | `transaction.md` → `saga-transaction.md`（事务和分布式事务） |
| **问题解决** | 使用 A 时可能遇到的问题在 B 中有解答 | `distributed-deployment.md` → `multi-pool.md`（分布式部署需要多连接池） |

#### 什么时候不应该建立引用关系？

以下情况**不应该**建立引用：

| 情况 | 原因 | 示例 |
|------|------|------|
| **仅仅属于同一项目** | 项目内所有文档都属于同一项目，不构成引用理由 | `find.md` ❌→ `update.md`（无逻辑关联） |
| **验证文件与功能文档** | 验证文件是内部文档，用户不需要关心 | `multi-pool.md` ❌→ `validation/checklists/multi-pool.md` |
| **功能文档与示例代码** | 示例代码已经包含在文档中 | `connection.md` ❌→ `examples/basic/connect.js` |
| **平行功能模块** | 两个独立功能，互不依赖 | `cache.md` ❌→ `business-lock.md` |

### 实际案例分析

#### 案例1: multi-pool.md 的引用关系

**✅ 应该引用的文档**:

```markdown
## 相关文档

- [连接管理](./connection.md) - ✅ 多连接池基于连接管理（依赖关系）
- [健康检查详解](./multi-pool-health-check.md) - ✅ 健康检查是多连接池的一部分（扩展关系）
- [分布式部署](./distributed-deployment.md) - ✅ 分布式部署通常需要多连接池（配套关系）
```

**❌ 不应该引用的文档**:

```markdown
## 相关文档

- [验证清单](../validation/checklists/multi-pool.md) - ❌ 验证文件是内部文档
- [验证脚本](../validation/validators/multi-pool.ts) - ❌ 用户不需要关心验证脚本
- [示例代码](../examples/multi-pool/basic.js) - ❌ 示例已经在文档中展示
- [find 查询](./find.md) - ❌ 与多连接池无直接关系
```

#### 案例2: connection.md 的引用关系

**✅ 应该引用的文档**:

```markdown
## 参考资料

- [MongoDB 官方文档](https://docs.mongodb.com/) - ✅ 依赖 MongoDB 驱动
- [SSH 隧道](./ssh-tunnel.md) - ✅ SSH 隧道也是连接方式之一（配套关系）
- [monSQLize README](../README.md) - ✅ 主文档
```

**❌ 不应该引用的文档**:

```markdown
## 参考资料

- [验证清单](../validation/checklists/connect.md) - ❌ 内部文档
- [多连接池](./multi-pool.md) - ❌ 多连接池依赖连接管理，不是反向依赖
- [缓存系统](./cache.md) - ❌ 与连接管理无直接关系
```

### 引用关系的方向性

**重要原则**：引用关系是有方向的，不是对称的。

```
A 引用 B ≠ B 引用 A
```

**示例**:

- ✅ `multi-pool.md` 引用 `connection.md`（多连接池依赖连接管理）
- ❌ `connection.md` 不应该引用 `multi-pool.md`（连接管理不需要知道多连接池）

- ✅ `multi-pool.md` 引用 `multi-pool-health-check.md`（主文档引用详细说明）
- ❌ `multi-pool-health-check.md` 不需要引用 `multi-pool.md`（详细文档已经说明了所属）

### 如何判断是否应该建立引用？

**判断流程**:

```
1. 问自己：用户在阅读 A 文档时，是否需要先看 B 文档才能理解？
   → 是：建立引用（依赖关系）
   → 否：继续下一步

2. 问自己：用户在使用 A 功能时，是否经常需要查阅 B 文档中的详细说明？
   → 是：建立引用（扩展关系）
   → 否：继续下一步

3. 问自己：A 和 B 是否在实际使用中经常一起出现？
   → 是：建立引用（配套关系）
   → 否：继续下一步

4. 问自己：用户在使用 A 时遇到的常见问题，是否在 B 中有解答？
   → 是：建立引用（问题解决）
   → 否：不建立引用
```

### 验证文件与功能文档的关系

**验证文件不应该出现在功能文档的引用中，原因**:

1. **目标读者不同**:
   - 功能文档：面向使用者
   - 验证文件：面向维护者和开发者

2. **内容性质不同**:
   - 功能文档：如何使用
   - 验证文件：如何验证实现是否正确

3. **访问路径不同**:
   - 用户通过 `docs/` 目录查找功能文档
   - 开发者通过 `validation/` 目录查找验证文件

**正确的做法**:

- ✅ 在 `validation/README.md` 中说明验证文件与功能文档的对应关系
- ✅ 在 `validation/checklists/` 中引用对应的功能文档（反向引用）
- ❌ 在功能文档中引用验证文件

### 总结

**引用关系的核心原则**:

1. ✅ **必须有实际的逻辑关联**（依赖、扩展、配套、问题解决）
2. ✅ **必须对用户有帮助**（帮助理解、帮助使用）
3. ✅ **引用方向要正确**（A 依赖 B ≠ B 依赖 A）
4. ❌ **不要引用内部文档**（验证文件、开发文档）
5. ❌ **不要引用无关文档**（仅因为同属一个项目）

---

## 📝 文件命名规范

### 验证清单命名

格式: `{功能名}.md`

示例:
- `connect.md` - 连接管理验证清单
- `find.md` - find 查询验证清单
- `aggregate.md` - 聚合查询验证清单

### 验证脚本命名

格式: `{功能名}.ts` 或 `{功能名}.js`

示例:
- `connect.ts` - 连接管理验证脚本
- `find.ts` - find 查询验证脚本

### 验证报告命名

格式: `{功能名}-validation-report.md`

示例:
- `connect-validation-report.md` - 连接管理验证报告
- `find-validation-report.md` - find 查询验证报告

### 总结文档命名

格式: `{主题}-summary.md` 或 `{主题}-{类型}.md`

示例:
- `CHECKLIST-UPDATE-SUMMARY.md` - 验证清单更新总结
- `monthly-validation-summary.md` - 月度验证总结

---

## 📝 验证完成后的文档优化

### 文档优化原则

验证完成后，应该根据验证结果优化对应的功能文档。**文档是给使用者看的，而不是给开发者看的。**

#### 核心原则

1. **用户视角优先**: 文档应该解答"如何使用"，而不是"如何实现"
2. **精简边界说明**: 边界情况会在运行时报错，无需在文档中详细列举
3. **突出核心用法**: 80% 的用户只需要 20% 的功能
4. **移除验证细节**: 参数验证、错误码等技术细节应该放到 API 参考文档

#### 文档类型划分

| 文档类型 | 目标读者 | 内容侧重 | 存放位置 |
|---------|---------|---------|---------|
| **用户文档** | 使用者 | 如何使用、常见场景、最佳实践 | `docs/{功能名}.md` |
| **API 参考** | 开发者 | 参数说明、返回值、错误码 | `docs/api/{功能名}-api.md` |
| **验证报告** | 维护者 | 验证结果、问题发现、改进建议 | `validation/reports/{功能名}-validation-report.md` |

### 文档优化检查清单

验证完成后，按照以下清单优化文档：

#### 1. 移除不必要的技术细节

**应该移除**:
- ❌ 详细的参数验证规则（如："不允许空字符串、null、undefined、数字、对象..."）
- ❌ 所有边界情况的示例代码
- ❌ 错误码的详细列举
- ❌ 内部实现机制说明（如："并发锁机制"、"延迟验证"）

**应该保留**:
- ✅ 基本使用方法
- ✅ 常见场景示例
- ✅ 最佳实践建议
- ✅ 简单的注意事项（一句话概括）

**优化示例**:

**优化前**（过于详细）:
```markdown
#### collection() 验证

**验证规则**：
- 必须是非空字符串
- 不允许 `null`、`undefined`、空字符串、纯空格
- 不允许数字、对象等其他类型

```javascript
// ❌ 无效参数（会抛出错误）
try {
  collection('');           // 错误：INVALID_COLLECTION_NAME - 空字符串
  collection('   ');        // 错误：INVALID_COLLECTION_NAME - 纯空格
  collection(null);         // 错误：INVALID_COLLECTION_NAME - null
  collection(undefined);    // 错误：INVALID_COLLECTION_NAME - undefined
  collection(123);          // 错误：INVALID_COLLECTION_NAME - 数字
  collection({ name: 'test' }); // 错误：INVALID_COLLECTION_NAME - 对象
} catch (err) {
  console.error(err.code, err.message);
}
```
```

**优化后**（简洁明了）:
```markdown
#### collection()

获取集合访问器。

```javascript
const users = collection('users');
const orders = collection('orders');
```

> **注意**: 集合名必须是有效的字符串，否则会抛出 `INVALID_COLLECTION_NAME` 错误。
```

#### 2. 突出核心使用场景

**调整内容比例**:
- 80% 篇幅：核心使用方法和常见场景
- 15% 篇幅：最佳实践和注意事项
- 5% 篇幅：错误处理（一句话带过）

**示例**:

**优化前**:
```markdown
## 连接管理 API (占 40%)
## 参数验证 (占 30%)
## 错误处理 (占 20%)
## 最佳实践 (占 10%)
```

**优化后**:
```markdown
## 快速开始 (占 40%)
## 常见场景 (占 30%)
## 最佳实践 (占 20%)
## 高级用法 (占 5%)
## 错误处理 (占 5%)
```

#### 3. 简化错误处理说明

**优化前**（详细列举）:
```markdown
#### 错误信息

| 错误码 | 说明 | 示例 |
|--------|------|------|
| `INVALID_COLLECTION_NAME` | 集合名无效 | `collection('')` |
| `INVALID_DATABASE_NAME` | 数据库名无效 | `db('').collection('test')` |

**注意**：
- `db(null)` 和 `db(undefined)` **不会**抛出错误
- 只有空字符串 `''` 和纯空格字符串 `'   '` 才会触发验证错误
```

**优化后**（简单概括）:
```markdown
#### 错误处理

使用时如果参数不正确，会抛出相应的错误。具体错误码请参考 [错误码文档](./error-codes.md)。
```

#### 4. 增加实用示例

**替换验证示例为实际场景**:

**优化前**（验证场景）:
```javascript
// 高并发场景：10 个并发请求
const promises = Array(10).fill(null).map(() => msq.connect());
const results = await Promise.all(promises);
console.log(results[0] === results[1]);  // true
```

**优化后**（实际场景）:
```javascript
// 在 Web 框架中使用
app.get('/users', async (req, res) => {
  const { collection } = await msq.connect();
  const users = await collection('users').find({ query: {} });
  res.json(users);
});

// 跨库查询
const { db } = await msq.connect();
const shopOrders = await db('shop').collection('orders').find({ query: {} });
const analyticsEvents = await db('analytics').collection('events').find({ query: {} });
```

### 文档优化流程

```
1. 验证完成
   └─> 100% 通过率，文档一致性确认

2. 分析文档问题
   └─> 识别过于详细的内容
   └─> 识别缺少的实用场景

3. 创建优化清单
   └─> docs/optimization/{功能名}-doc-optimization.md

4. 优化文档
   └─> 移除技术细节
   └─> 简化错误处理
   └─> 增加实用示例
   └─> 调整内容比例

5. 提取技术文档
   └─> 将边界情况移至 docs/api/{功能名}-api.md
   └─> 将验证细节移至 validation/reports/

6. 更新验证报告
   └─> 在验证报告中记录文档优化内容

7. 验证优化效果
   └─> 让新用户试读文档
   └─> 收集反馈并调整
```

### 文档优化模板

创建 `docs/optimization/{功能名}-doc-optimization.md`:

```markdown
# {功能名}文档优化清单

## 验证完成信息
- 验证日期: 2026-02-03
- 通过率: 100%
- 文档一致性: 完全一致

## 优化目标
基于验证结果，优化文档的可读性和实用性。

## 需要移除的内容

### 1. 过于详细的验证规则
- [ ] 移除所有边界情况示例
- [ ] 移除详细的错误码列表
- [ ] 移除参数验证的详细说明

### 2. 技术实现细节
- [ ] 移除并发锁机制说明
- [ ] 移除延迟验证机制说明
- [ ] 移除内部实现原理

## 需要增加的内容

### 1. 实用示例
- [ ] Web 框架集成示例
- [ ] 常见业务场景
- [ ] 性能优化建议

### 2. 最佳实践
- [ ] 连接管理最佳实践
- [ ] 资源清理建议
- [ ] 常见陷阱提醒

## 内容重组

### 优化前
- 连接管理 API (40%)
- 参数验证 (30%)
- 错误处理 (20%)
- 最佳实践 (10%)

### 优化后
- 快速开始 (40%)
- 常见场景 (30%)
- 最佳实践 (20%)
- 错误处理 (5%)
- API 参考 (5%)

## 技术文档迁移

移至 `docs/api/connection-api.md`:
- 完整的参数说明
- 详细的错误码
- 边界情况处理
- 参数验证规则

## 预期效果
- 文档长度减少 50%
- 用户理解时间减少 60%
- 快速上手时间 < 5 分钟
```

### 示例：connection.md 优化建议

基于连接管理的验证结果，以下是具体优化建议：

#### 移除内容

1. **参数验证章节**（约 100 行）
   - 移除所有 `❌ 无效参数` 示例
   - 移除详细的验证规则说明
   - 移至 `docs/api/connection-api.md`

2. **并发连接保护机制**（约 50 行）
   - 移除工作原理说明
   - 移除并发保护的优势列表
   - 保留一句话："自动处理并发连接"

3. **错误信息表格**
   - 移除详细的错误码表格
   - 改为："参数错误会抛出相应异常"

#### 保留并优化

1. **快速开始**（新增）
   ```javascript
   const { collection } = await msq.connect();
   const users = await collection('users').find({ query: {} });
   ```

2. **常见场景**（新增）
   - Web 框架集成
   - 跨库查询
   - 资源清理

3. **最佳实践**（优化）
   - 连接复用
   - 错误处理
   - 资源管理

#### 预期效果

- 文档从 651 行减少到 ~300 行
- 用户快速上手时间 < 5 分钟
- 技术细节移至 API 参考文档

---

## 🔄 验证流程

### 完整验证流程（8 步）

```
1. 创建验证清单
   └─> checklists/{功能名}.md

2. 编写验证脚本
   └─> validators/{功能名}.ts

3. 运行验证脚本
   └─> node validators/{功能名}.ts

4. 分析验证结果
   └─> 检查通过率和失败项

5. 更新验证清单
   └─> 标记所有验证项为 ✅

6. 生成验证报告
   └─> reports/{功能名}-validation-report.md

7. 优化功能文档 🆕
   └─> 简化用户文档，提取技术文档

8. 更新总进度
   └─> VERIFICATION-PROGRESS.md
```

### 验证清单创建

1. **分析文档内容**
   - 阅读对应的功能文档 (docs/{功能名}.md)
   - 提取所有功能点和特性描述
   - 识别关键验证场景

2. **设计验证项**
   - 按功能分类组织验证项
   - 定义明确的验证标准
   - 设定验证优先级（P0/P1/P2）

3. **编写验证清单**
   - 使用统一的 Markdown 格式
   - 包含导航目录和快速跳转
   - 添加验证状态追踪

### 验证脚本编写

1. **脚本结构**
   ```typescript
   // 引入依赖
   const MonSQLize = require('../../lib');
   
   // 验证统计
   const stats = { total: 0, passed: 0, failed: 0, errors: [] };
   
   // 辅助函数
   function assert(condition, testName) { ... }
   
   // 验证测试
   (async () => {
       // 分类 1: 测试项
       console.log('📦 分类 1: ...');
       // 验证逻辑
       
       // 验证总结
       console.log('验证总结');
   })();
   ```

2. **验证要求**
   - 覆盖所有验证清单项
   - 包含正常和异常场景
   - 自动化断言和统计
   - 详细的错误信息

### 验证报告生成

1. **报告结构**
   - 验证摘要
   - 分类统计
   - 关键验证点
   - 文档准确性评估
   - 改进建议

2. **报告内容**
   - 通过率统计
   - 失败项详情
   - 性能指标
   - 发现的问题

---

## 📊 验证状态追踪

### 状态图例

| 图标 | 状态 | 说明 |
|------|------|------|
| ⏳ | 待验证 | 尚未开始验证 |
| 🔄 | 验证中 | 正在进行验证 |
| ✅ | 已完成 | 验证通过，文档一致 |
| ⚠️ | 有问题 | 发现问题，需要修复 |

### 验证清单状态

在 `checklists/{功能名}.md` 中：

- `[ ]` - 待验证
- `[x]` - 已验证

示例:
```markdown
- [x] **1.1 基础连接** ✅
  - [x] 调用 `connect()` 返回对象包含 `db`, `collection`
  - [x] 返回的 `db` 是函数类型
```

### 总进度追踪

在 `VERIFICATION-PROGRESS.md` 中：

- 功能模块列表（85 个）
- 每个功能的状态
- 验证日期
- 完成度统计

---

## 🚀 快速开始

### 验证现有功能

1. **查看已完成的验证示例**
   ```bash
   # 查看连接管理验证清单
   cat validation/checklists/connect.md
   
   # 查看验证报告
   cat validation/reports/connect-validation-report.md
   ```

2. **运行验证脚本**
   ```bash
   cd E:\MySelf\monSQLize
   
   # 运行连接管理验证
   npx tsx validation/validators/connect.ts
   ```

3. **查看验证结果**
   - 控制台输出：详细的验证过程和结果
   - 验证报告：reports/{功能名}-validation-report.md
   - 总进度：VERIFICATION-PROGRESS.md

### 创建新的验证

1. **创建验证清单**
   ```bash
   # 复制模板
   cp validation/checklists/connect.md validation/checklists/{新功能}.md
   
   # 编辑清单
   # 根据文档内容调整验证项
   ```

2. **编写验证脚本**
   ```bash
   # 复制模板
   cp validation/validators/connect.ts validation/validators/{新功能}.ts
   
   # 编辑脚本
   # 实现验证逻辑
   ```

3. **运行验证**
   ```bash
   npx tsx validation/validators/{新功能}.ts
   ```

4. **生成报告**
   - 根据验证结果创建报告文档
   - 保存到 reports/ 目录

5. **更新进度**
   - 更新 VERIFICATION-PROGRESS.md
   - 标记功能为已验证 ✅

---

## ❓ 常见问题

### Q1: 如何确定验证项的优先级？

**A**: 使用三级优先级：

- **P0 (关键)**: 核心功能，必须验证
  - 基础连接、数据读写、错误处理
- **P1 (重要)**: 重要功能，强烈建议验证
  - 跨库访问、参数验证、资源清理
- **P2 (可选)**: 性能和优化项，建议验证
  - 高并发场景、内存管理、连接复用

### Q2: 验证脚本运行失败怎么办？

**A**: 按以下步骤排查：

1. 检查 MongoDB 服务是否运行
2. 检查依赖是否安装（npm install）
3. 检查数据库连接配置
4. 查看详细错误信息
5. 参考已通过的验证脚本（如 connect.ts）

### Q3: 如何更新验证清单状态？

**A**: 手动更新步骤：

1. 运行验证脚本
2. 记录通过/失败的验证项
3. 在验证清单中勾选 `[x]` 已通过的项
4. 更新统计表格中的数字
5. 更新验证记录（日期、结果）

### Q4: 验证报告应该包含哪些内容？

**A**: 标准报告结构：

- 验证摘要（总数、通过、失败、通过率）
- 分类统计（各分类的详细数据）
- 关键验证点（重要发现）
- 文档准确性评估
- 改进建议（针对文档或代码）

### Q5: 如何处理验证失败的情况？

**A**: 失败处理流程：

1. **分析失败原因**
   - 文档描述错误？
   - 代码实现问题？
   - 验证脚本有误？

2. **修复问题**
   - 更新文档（如果文档错误）
   - 修复代码（如果代码有问题）
   - 调整验证脚本（如果脚本有误）

3. **重新验证**
   - 修复后重新运行验证
   - 确认问题已解决

4. **记录问题**
   - 在报告中记录发现的问题
   - 记录修复过程
   - 总结经验教训

---

## 📚 参考资料

### 相关文档

- [VERIFICATION-PROGRESS.md](./VERIFICATION-PROGRESS.md) - 总进度追踪
- [checklists/connect.md](./checklists/connect.md) - 连接管理验证清单（示例）
- [reports/connect-validation-report.md](./reports/connect-validation-report.md) - 连接管理验证报告（示例）

### 功能文档

- [docs/connection.md](../docs/connection.md) - 连接管理功能文档
- [docs/find.md](../docs/find.md) - find 查询功能文档
- [docs/aggregate.md](../docs/aggregate.md) - 聚合查询功能文档

### 代码参考

- [lib/connect.js](../lib/connect.js) - 连接管理实现
- [lib/mongodb/queries/find.js](../lib/mongodb/queries/find.js) - find 查询实现

---

## 🔗 相关链接

- **项目主页**: [monSQLize](https://github.com/yourusername/monSQLize)
- **文档目录**: [docs/](../docs/)
- **测试目录**: [test/](../test/)
- **问题追踪**: [GitHub Issues](https://github.com/yourusername/monSQLize/issues)

---

## ✅ 验证完成标准

一个功能模块达到以下标准即可标记为验证完成：

1. ✅ **验证清单完成**: 所有验证项勾选 ✅
2. ✅ **通过率 100%**: 所有验证测试通过
3. ✅ **文档一致性**: 文档与代码完全一致
4. ✅ **验证报告生成**: 完整的验证报告
5. ✅ **总进度更新**: 同步更新 VERIFICATION-PROGRESS.md

---

## 📈 验证进度概览

### 当前统计（截至 2026-02-03）

| 指标 | 数值 | 进度 |
|------|------|------|
| **总功能数** | 85 | 100% |
| **已验证** | 1 | 1.2% |
| **待验证** | 84 | 98.8% |
| **文档覆盖** | 100% | 71 已存在 + 14 已规划 |

### 已完成验证

| 日期 | 功能 | 验证项 | 通过率 | 报告 |
|------|------|--------|--------|------|
| 2026-02-03 | 连接管理 | 62 | 100% | [查看报告](./reports/connect-validation-report.md) |

### 下一步计划

- **1.2 多连接池** - 计划验证
- **1.3 SSH 隧道** - 计划验证
- **2.1 find 查询** - 计划验证

---

## 📝 文档规范说明

### 文档目录格式规范

**所有文档必须遵循统一的目录格式**（参考 `docs/connection.md`）：

```markdown
## 📑 目录

- [概述](#概述)
- [核心特性](#核心特性)
- [API 详细说明](#api-详细说明)
  - [方法1](#方法1)
  - [方法2](#方法2)
- [配置选项](#配置选项)
  - [完整配置示例](#完整配置示例)
  - [配置分类说明](#配置分类说明)
- [最佳实践](#最佳实践)
- [常见问题](#常见问题)
```

**规范要点**:
1. ✅ 使用 `## 📑 目录` 作为标题
2. ✅ 使用 `-` 列表格式（不使用数字编号）
3. ✅ 章节标题不带数字编号（例如：`## 核心概念` 而非 `## 1. 核心概念`）
4. ✅ 锚点使用小写，空格用 `-` 连接（例如：`#核心特性`）
5. ❌ 不使用 `### [1.1 标题](#11-标题)` 这种数字编号格式

### 文档内容规范

**面向用户的文档设计**:

1. **结构清晰**:
   - 先介绍核心概念
   - 再展示快速上手示例
   - 最后是详细 API 文档

2. **示例优先**:
   - 80% 实际使用示例
   - 15% 最佳实践
   - 5% 错误处理

3. **简洁明了**:
   - 避免冗长的参数验证示例
   - 突出核心功能和常见场景
   - 错误处理简单说明即可

4. **禁止内容**:
   - ❌ 不要在文档头部添加 "文档状态: ✅ 已与代码完全同步"
   - ❌ 不要过度强调内部实现细节
   - ❌ 不要列举所有可能的错误场景

### 文档更新流程

**完成文档更新后必须执行以下步骤**:

#### 1. 删除备份文档

更新完成后，立即删除临时备份的旧文档，避免混淆：

```bash
# 示例
rm docs/multi-pool-old-20260203.md
```

#### 2. 验证文档与代码一致性

使用三方对比验证方法：

```
┌─────────────┐
│   文档描述   │ ← 用户看到的 API 说明
└─────────────┘
       ↓
┌─────────────┐
│  代码实现    │ ← 实际的功能代码
└─────────────┘
       ↓
┌─────────────┐
│  验证脚本    │ ← 自动化测试
└─────────────┘
```

**验证步骤**:

a. **运行文档一致性验证**:
```bash
node validation/validators/doc-consistency.ts
```
检查文档示例是否可以直接运行。

b. **运行功能完整验证**:
```bash
node validation/validators/{功能名}.ts
```
检查所有 API 是否按文档描述工作。

c. **对比验证结果**:
- ✅ 所有 API 方法是否都有文档说明
- ✅ 所有参数是否与代码实现一致
- ✅ 所有返回值是否与文档描述匹配
- ✅ 所有错误类型是否正确列出
- ✅ 所有示例代码是否可以运行

#### 3. 更新验证清单

在对应的验证清单中记录验证结果：

```bash
# 更新验证清单
vim validation/checklists/{功能名}.md

# 更新总进度
vim validation/VERIFICATION-PROGRESS.md
```

#### 4. 生成验证报告

创建详细的验证报告：

```bash
# 报告命名格式
validation/reports/{功能名}-verification-complete.md

# 包含内容：
# - 验证项统计
# - 发现的问题（如有）
# - 修复记录
# - 最终一致性确认
```

### 验证通过标准

文档验证通过的条件：

| 验证项 | 标准 | 说明 |
|--------|------|------|
| **API 完整性** | 100% | 所有 API 都有文档说明 |
| **参数一致性** | 100% | 参数类型、默认值与代码一致 |
| **返回值一致性** | 100% | 返回值结构与代码一致 |
| **示例可用性** | 100% | 所有示例可以直接运行 |
| **错误处理** | 100% | 错误类型与代码一致 |
| **测试覆盖** | ≥ 80% | 核心功能有测试验证 |

---

## 🤝 贡献指南

欢迎贡献验证脚本和改进建议！

### 贡献步骤

1. Fork 项目
2. 创建验证分支
3. 编写验证清单和脚本
4. 运行验证并生成报告
5. 提交 Pull Request

### 贡献要求

- 遵循文件命名规范
- 提供完整的验证清单
- 验证脚本可独立运行
- 生成详细的验证报告
- 更新总进度文档

---

**最后更新**: 2026-02-03  
**维护者**: monSQLize Team  
**版本**: v1.0.0
